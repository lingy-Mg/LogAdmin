# 任务 05: 日志归档和清理系统

## 目标
实现自动日志归档、压缩、清理功能，包括定时任务调度和存储管理。

## 执行步骤

### 1. 安装依赖
```bash
cd packages/backend
pnpm add node-cron      # 定时任务
pnpm add archiver       # 文件压缩
pnpm add fs-extra       # 文件操作增强
```

### 2. 创建归档服务

#### 2.1 归档服务 (`src/services/archive.service.ts`)
实现方法：
- `archiveDailyLogs(date: Date): Promise<void>` - 归档指定日期的日志
- `archiveDeviceLogs(deviceId: string, date: Date): Promise<void>` - 归档设备日志
- `compressLogFile(filePath: string): Promise<string>` - 压缩日志文件
- `moveToArchive(sourcePath: string, targetPath: string): Promise<void>` - 移动到归档目录
- `getArchivePath(date: Date): string` - 获取归档路径
- `listArchives(): Promise<ArchiveInfo[]>` - 列出归档文件

#### 2.2 清理服务 (`src/services/cleanup.service.ts`)
实现方法：
- `cleanOldArchives(retentionDays: number): Promise<void>` - 清理过期归档
- `getArchiveAge(filePath: string): number` - 获取归档文件年龄
- `calculateStorageUsage(): Promise<StorageInfo>` - 计算存储使用
- `checkDiskSpace(): Promise<DiskSpaceInfo>` - 检查磁盘空间
- `moveToObjectStorage(filePath: string): Promise<void>` - 迁移到对象存储（可选）

#### 2.3 索引服务 (`src/services/index.service.ts`)
实现方法：
- `createArchiveIndex(archiveInfo: ArchiveInfo): Promise<void>` - 创建归档索引
- `updateArchiveIndex(archiveId: string, info: Partial<ArchiveInfo>): Promise<void>` - 更新索引
- `searchArchives(query: ArchiveQuery): Promise<ArchiveInfo[]>` - 搜索归档
- `getArchiveMetadata(archiveId: string): Promise<ArchiveInfo | null>` - 获取归档元数据

### 3. 创建定时任务

#### 3.1 归档任务 (`src/jobs/archive.job.ts`)
实现：
```typescript
import cron from 'node-cron'
import { archiveService } from '../services/archive.service'
import { logger } from '../utils/logger'
import { config } from '../config'

// 每天凌晨 2:00 执行归档
export function scheduleArchiveJob() {
  const cronTime = config.storage.archiveTime || '0 2 * * *'
  
  cron.schedule(cronTime, async () => {
    try {
      logger.info('Starting daily archive job')
      
      const yesterday = new Date()
      yesterday.setDate(yesterday.getDate() - 1)
      
      await archiveService.archiveDailyLogs(yesterday)
      
      logger.info('Daily archive job completed')
    } catch (error) {
      logger.error('Archive job failed:', error)
    }
  })
  
  logger.info(`Archive job scheduled at ${cronTime}`)
}
```

#### 3.2 清理任务 (`src/jobs/cleanup.job.ts`)
实现：
```typescript
// 每天凌晨 3:00 执行清理
export function scheduleCleanupJob() {
  cron.schedule('0 3 * * *', async () => {
    try {
      logger.info('Starting cleanup job')
      
      const retentionDays = config.storage.retentionDays || 90
      await cleanupService.cleanOldArchives(retentionDays)
      
      // 检查存储空间
      const storageInfo = await cleanupService.calculateStorageUsage()
      logger.info('Storage usage:', storageInfo)
      
      // 如果空间不足，触发告警
      const diskSpace = await cleanupService.checkDiskSpace()
      if (diskSpace.usagePercent > 80) {
        logger.warn('Disk space warning:', diskSpace)
        // 触发告警通知
      }
      
      logger.info('Cleanup job completed')
    } catch (error) {
      logger.error('Cleanup job failed:', error)
    }
  })
}
```

#### 3.3 统计任务 (`src/jobs/statistics.job.ts`)
实现：
```typescript
// 每小时执行统计聚合
export function scheduleStatisticsJob() {
  cron.schedule('0 * * * *', async () => {
    try {
      logger.info('Starting statistics aggregation')
      
      await statisticsService.aggregateHourlyStats()
      
      logger.info('Statistics aggregation completed')
    } catch (error) {
      logger.error('Statistics job failed:', error)
    }
  })
}
```

### 4. 实现文件压缩

#### 4.1 压缩工具增强 (`src/utils/compression.ts`)
实现方法：
```typescript
import archiver from 'archiver'
import fs from 'fs-extra'
import path from 'path'
import { pipeline } from 'stream/promises'
import zlib from 'zlib'

export class CompressionUtil {
  /**
   * Gzip 压缩单个文件
   */
  async gzipFile(inputPath: string, outputPath?: string): Promise<string> {
    const output = outputPath || `${inputPath}.gz`
    
    await pipeline(
      fs.createReadStream(inputPath),
      zlib.createGzip(),
      fs.createWriteStream(output)
    )
    
    return output
  }

  /**
   * 压缩目录为 tar.gz
   */
  async compressDirectory(dirPath: string, outputPath: string): Promise<void> {
    const output = fs.createWriteStream(outputPath)
    const archive = archiver('tar', { gzip: true })

    archive.pipe(output)
    archive.directory(dirPath, false)
    await archive.finalize()

    return new Promise((resolve, reject) => {
      output.on('close', resolve)
      archive.on('error', reject)
    })
  }

  /**
   * 批量压缩文件
   */
  async compressBatch(files: string[]): Promise<string[]> {
    const results = await Promise.all(
      files.map(file => this.gzipFile(file))
    )
    return results
  }
}
```

### 5. 实现存储管理

#### 5.1 存储管理器 (`src/utils/storageManager.ts`)
实现：
```typescript
import fs from 'fs-extra'
import path from 'path'
import { logger } from './logger'

export interface StorageInfo {
  totalSize: number
  archiveSize: number
  rawSize: number
  fileCount: number
  oldestFile: string
  newestFile: string
}

export interface DiskSpaceInfo {
  total: number
  used: number
  free: number
  usagePercent: number
}

export class StorageManager {
  constructor(private basePath: string) {}

  /**
   * 计算目录大小
   */
  async getDirectorySize(dirPath: string): Promise<number> {
    let totalSize = 0
    const files = await fs.readdir(dirPath, { withFileTypes: true })

    for (const file of files) {
      const filePath = path.join(dirPath, file.name)
      
      if (file.isDirectory()) {
        totalSize += await this.getDirectorySize(filePath)
      } else {
        const stats = await fs.stat(filePath)
        totalSize += stats.size
      }
    }

    return totalSize
  }

  /**
   * 获取存储信息
   */
  async getStorageInfo(): Promise<StorageInfo> {
    const rawPath = path.join(this.basePath, 'raw')
    const archivePath = path.join(this.basePath, 'archived')

    const [rawSize, archiveSize] = await Promise.all([
      this.getDirectorySize(rawPath),
      this.getDirectorySize(archivePath)
    ])

    return {
      totalSize: rawSize + archiveSize,
      rawSize,
      archiveSize,
      fileCount: 0, // TODO: 计算文件数量
      oldestFile: '',
      newestFile: ''
    }
  }

  /**
   * 检查磁盘空间
   */
  async checkDiskSpace(): Promise<DiskSpaceInfo> {
    // 使用 fs.statfs 或系统命令
    // 这里简化实现
    return {
      total: 0,
      used: 0,
      free: 0,
      usagePercent: 0
    }
  }

  /**
   * 清理临时文件
   */
  async cleanTempFiles(): Promise<void> {
    const tempPath = path.join(this.basePath, 'temp')
    if (await fs.pathExists(tempPath)) {
      await fs.emptyDir(tempPath)
    }
  }
}
```

### 6. 创建归档数据模型

#### 6.1 归档模型 (`src/models/Archive.ts`)
```typescript
import { Schema, model } from 'mongoose'

export interface ArchiveInfo {
  id: string
  date: Date
  deviceId?: string
  filePath: string
  compressedPath: string
  originalSize: number
  compressedSize: number
  compressionRatio: number
  logCount: number
  startTime: Date
  endTime: Date
  createdAt: Date
  status: 'pending' | 'completed' | 'failed'
  error?: string
}

const archiveSchema = new Schema<ArchiveInfo>({
  id: { type: String, required: true, unique: true },
  date: { type: Date, required: true, index: true },
  deviceId: { type: String, index: true },
  filePath: { type: String, required: true },
  compressedPath: { type: String, required: true },
  originalSize: { type: Number, required: true },
  compressedSize: { type: Number, required: true },
  compressionRatio: { type: Number, required: true },
  logCount: { type: Number, required: true },
  startTime: { type: Date, required: true },
  endTime: { type: Date, required: true },
  createdAt: { type: Date, default: Date.now },
  status: { type: String, enum: ['pending', 'completed', 'failed'], default: 'pending' },
  error: String
})

export const ArchiveModel = model<ArchiveInfo>('Archive', archiveSchema)
```

### 7. 实现归档核心逻辑

#### 7.1 归档服务完整实现
```typescript
export class ArchiveService {
  constructor(
    private storagePath: string,
    private compressionUtil: CompressionUtil
  ) {}

  /**
   * 归档指定日期的所有日志
   */
  async archiveDailyLogs(date: Date): Promise<void> {
    logger.info(`Archiving logs for date: ${date.toISOString().split('T')[0]}`)
    
    // 1. 获取当天的所有日志文件
    const rawPath = path.join(this.storagePath, 'raw')
    const dateStr = format(date, 'yyyyMMdd')
    const files = await this.getLogFiles(rawPath, dateStr)

    logger.info(`Found ${files.length} files to archive`)

    // 2. 按设备分组归档
    const deviceGroups = this.groupFilesByDevice(files)

    for (const [deviceId, deviceFiles] of Object.entries(deviceGroups)) {
      await this.archiveDeviceFiles(deviceId, date, deviceFiles)
    }

    // 3. 创建归档索引
    await this.createDailyIndex(date)

    logger.info('Archive completed')
  }

  /**
   * 归档设备文件
   */
  private async archiveDeviceFiles(
    deviceId: string,
    date: Date,
    files: string[]
  ): Promise<void> {
    try {
      // 1. 创建归档目录
      const archivePath = this.getArchivePath(date, deviceId)
      await fs.ensureDir(path.dirname(archivePath))

      // 2. 合并文件（如果有多个切割文件）
      const mergedFile = await this.mergeLogFiles(files, archivePath)

      // 3. 压缩文件
      const compressedFile = await this.compressionUtil.gzipFile(mergedFile)

      // 4. 获取文件信息
      const originalSize = (await fs.stat(mergedFile)).size
      const compressedSize = (await fs.stat(compressedFile)).size

      // 5. 删除原始文件
      await fs.remove(mergedFile)
      for (const file of files) {
        await fs.remove(file)
      }

      // 6. 保存归档信息
      await ArchiveModel.create({
        id: `${deviceId}_${format(date, 'yyyyMMdd')}`,
        date,
        deviceId,
        filePath: mergedFile,
        compressedPath: compressedFile,
        originalSize,
        compressedSize,
        compressionRatio: compressedSize / originalSize,
        logCount: 0, // TODO: 从文件统计
        startTime: date,
        endTime: date,
        status: 'completed'
      })

      logger.info(`Archived ${deviceId} logs: ${files.length} files, ${originalSize} -> ${compressedSize} bytes`)
    } catch (error) {
      logger.error(`Archive failed for device ${deviceId}:`, error)
      throw error
    }
  }

  /**
   * 获取归档路径
   */
  private getArchivePath(date: Date, deviceId: string): string {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    const dateStr = format(date, 'yyyyMMdd')

    return path.join(
      this.storagePath,
      'archived',
      String(year),
      month,
      day,
      `${deviceId}_${dateStr}.log`
    )
  }

  /**
   * 合并日志文件
   */
  private async mergeLogFiles(files: string[], outputPath: string): Promise<string> {
    const output = fs.createWriteStream(outputPath)

    for (const file of files) {
      const input = fs.createReadStream(file)
      await pipeline(input, output, { end: false })
    }

    output.end()
    return outputPath
  }
}
```

### 8. 实现清理逻辑

```typescript
export class CleanupService {
  async cleanOldArchives(retentionDays: number): Promise<void> {
    logger.info(`Cleaning archives older than ${retentionDays} days`)

    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays)

    // 1. 查找过期归档
    const oldArchives = await ArchiveModel.find({
      date: { $lt: cutoffDate }
    })

    logger.info(`Found ${oldArchives.length} old archives to clean`)

    // 2. 删除文件
    for (const archive of oldArchives) {
      try {
        if (await fs.pathExists(archive.compressedPath)) {
          await fs.remove(archive.compressedPath)
        }
        await ArchiveModel.deleteOne({ _id: archive._id })
        logger.info(`Deleted archive: ${archive.id}`)
      } catch (error) {
        logger.error(`Failed to delete archive ${archive.id}:`, error)
      }
    }

    logger.info('Cleanup completed')
  }
}
```

### 9. 集成到主应用

在 `src/server.ts` 中启动定时任务：
```typescript
import { scheduleArchiveJob } from './jobs/archive.job'
import { scheduleCleanupJob } from './jobs/cleanup.job'
import { scheduleStatisticsJob } from './jobs/statistics.job'

// 启动定时任务
scheduleArchiveJob()
scheduleCleanupJob()
scheduleStatisticsJob()

logger.info('Scheduled jobs started')
```

### 10. 创建管理 API

#### 10.1 归档路由 (`src/routes/archive.routes.ts`)
```typescript
router.get('/archives', archiveController.listArchives)
router.get('/archives/:id', archiveController.getArchive)
router.post('/archives/trigger', archiveController.triggerArchive)
router.get('/archives/storage/info', archiveController.getStorageInfo)
router.delete('/archives/:id', archiveController.deleteArchive)
```

## 验收标准
- [ ] 定时归档任务正常执行（每天凌晨 2:00）
- [ ] 日志文件正确归档到按日期组织的目录
- [ ] 文件正确压缩（gzip）
- [ ] 归档索引正确创建
- [ ] 清理任务正常执行（删除过期归档）
- [ ] 存储信息统计正确
- [ ] 手动触发归档功能正常
- [ ] 归档文件可以正确查询和检索

## 测试方法

### 1. 手动触发归档
```bash
curl -X POST http://localhost:3000/api/archives/trigger \
  -H "Content-Type: application/json" \
  -d '{ "date": "2025-01-02" }'
```

### 2. 查看存储信息
```bash
curl http://localhost:3000/api/archives/storage/info
```

### 3. 列出归档
```bash
curl http://localhost:3000/api/archives
```

### 4. 验证目录结构
```bash
ls -lh packages/backend/logs/archived/2025/01/03/
# 应该看到压缩的日志文件
```

## 预期产出文件
```
packages/backend/src/
├── services/
│   ├── archive.service.ts
│   ├── cleanup.service.ts
│   └── index.service.ts
├── jobs/
│   ├── archive.job.ts
│   ├── cleanup.job.ts
│   └── statistics.job.ts
├── utils/
│   ├── compression.ts (增强)
│   └── storageManager.ts
├── models/
│   └── Archive.ts
├── routes/
│   └── archive.routes.ts
└── controllers/
    └── archive.controller.ts
```

## 下一步
完成后继续执行 `06-WebSocket实时推送.md`
